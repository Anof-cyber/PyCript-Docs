{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The Pycript extension for Burp Suite is a valuable tool for penetration testing and security professionals. It enables easy encryption and decryption of requests during testing, which can help evade detection and bypass security measures. The extension also offers the ability to customize the encryption and decryption process by writing custom logic using JavaScript and Node.js, making it a highly adaptable tool for various needs. Additionally, it supports both manual and automated testing, as well as custom encryption/decryption plugins, making it a versatile solution for different penetration testing scenarios.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ability to decrypt requests and modify data in real-time</li> <li>Provides JavaScript and NodeJS support for custom encryption and decryption logic.</li> <li>The ability to retrieve the encryption key and IV directly from the request header and body using Burpsuite and JavaScript.</li> <li>Supports decryption of multiple requests </li> <li>Use auto-encryption to perform an automated burp scan or sqlmap</li> </ul>"},{"location":"#sponsor","title":"Sponsor","text":""},{"location":"#team","title":"Team","text":""},{"location":"#sourav-kalal","title":"Sourav Kalal","text":""},{"location":"#documentation","title":"Documentation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#writing-custom-scripts","title":"Writing Custom Scripts","text":""},{"location":"#video","title":"Video","text":""},{"location":"Examples/","title":"Usage Examples","text":""},{"location":"Examples/#config","title":"Config","text":"<p>The configuration tab contains all the necessary settings to enable encryption and decryption functionality. Within the configuration, you can select whether to apply encryption and decryption to requests, responses, or both. Additionally, you can specify the preferred programming language and load any necessary encryption/decryption files, among other options.</p> <p>Warning</p> <p>This extension is designed to operate exclusively on URLs that have been included within the target scope of Burp Suite.</p>"},{"location":"Examples/#request-type","title":"Request Type","text":"<p>The Request Type feature enables you to choose the specific request or message type that requires encryption or decryption.</p> Complete BodyParameter ValueParameter Key and ValueCustom RequestCustom Request Edit Header <p>The \"Complete Body\" option within the request type of your Burp Suite extension offers valuable functionality in various scenarios. It proves useful when the entire request body is encrypted, or when the body contains encrypted data along with key/iv within it. Additionally, this option is beneficial if you desire to implement custom parsing of the request body through a script of your choice.</p> <p>By selecting the \"Complete Body\" option, Pycript will take the entire request body and pass it to the encryption and decryption script provided by the user. This allows for seamless integration of your own encryption and decryption logic with Burp Suite.</p> Example 1Example 2 <pre><code>POST /api/getuser HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 24\n\nAEIwJOtaQXdO9qzIJFIhEQ==\n</code></pre> <p></p> <p><pre><code>POST /api/getuser2 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 88\n\n{\"user_id\": \"W12wkCO+v4IOkEN3ENbRNQ==\",\"key\":\"mysecretkey12345\",\"iv\":\"n2r5u8x/A%D*G-Ka\"}\n</code></pre> </p> <p>When dealing with multiple parameters, where only the parameter values are encrypted, the parameter value can be retrieved from query parameters, JSON values, or body parameters. The PyCript module handles this process by passing one parameter value at a time to the user-provided script. The complete body or parameters are not passed to the script.</p> Example 1Example 2Example 3 <p><pre><code>POST /api/getuser2 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 39\n\n{\"user_id\": \"kmcduz+eWvqNbPAq//UQGA==\"}\n</code></pre> </p> <pre><code>GET /api/getuser5?user_id=W12wkCO+v4IOkEN3ENbRNQ== HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\n</code></pre> <p></p> <pre><code>POST /api/getuser5?user_id=kmcduz+eWvqNbPAq//UQGA== HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 39\n\n{\"user_id\": \"kmcduz+eWvqNbPAq//UQGA==\"}\n</code></pre> <p></p> <p>The Parameter Key and Value method proves to be valuable when dealing with encrypted parameter names and values in an application. By utilizing Pycript, the extension follows a consistent process of combining each parameter and its corresponding value. Subsequently, it proceeds to individually pass each resulting string to the encryption and decryption script.</p> Example 1 <pre><code>POST /api/getuser3 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 56\n\n{\"elHLzVxVH4e3AayiZkfB9g==\": \"W12wkCO+v4IOkEN3ENbRNQ==\"}\n</code></pre> <p></p> <p>The custom request feature is valuable for executing specific actions using scripts. It proves particularly helpful in scenarios where the request body is encrypted, and the encryption key or initialization vector (IV) is stored in the header. In such cases, the \"Complete Body\" option cannot be used.</p> <p>When utilizing the Custom Request type, both the request body and header are passed to the script for encryption and decryption purposes. This functionality enables you to access and analyze the headers while performing the necessary encryption or decryption operations.</p> Example 1 <pre><code>POST /api/getuser HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nKey: mysecretkey12345\nIv: n2r5u8x/A%D*G-Ka\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 24\n\nAEIwJOtaQXdO9qzIJFIhEQ==\n</code></pre> <p></p> <p>The \"Custom Request Edit Header\" feature was introduced in version 0.2 of the Burp Suite extension. It provides the capability to modify the request header. This functionality is not limited to editing alone; you can also add or delete headers as needed. It proves to be particularly useful in applications where data modification is restricted through various proxy or validation mechanisms, such as adding a signature to request parameters or body and enforcing signature verification to prevent any value modification.</p> Example 1 <pre><code>POST /api/getuser4 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nSignature: 7d1b73091d0f089a3a790af24404f6b4\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 39\n\n{\"user_id\": \"W12wkCO+v4IOkEN3ENbRNQ==\"}\n</code></pre> <p></p>"},{"location":"Examples/#response-type","title":"Response Type","text":"<p>The Response Type feature enables you to choose the specific response or message type that requires encryption or decryption.</p> <p>Warning</p> <p>The encryption and decryption of responses were introduced in PyCript v0.2. Please note that this functionality is currently limited to JSON response content types.</p> <p>Info</p> <p>If your complete response body is encrypted and there are possibilities that body will be in double/single quotes. You need to handle the same in your script.</p> <p>Info</p> <p>The Response Type in your Burp Suite extension mirrors the functionality of the request type. In fact, you can utilize the same script for both request and response actions, with the exception of the Custom Request and Custom Request (Edit Header) options.</p>"},{"location":"Examples/#additional-setting","title":"Additional Setting","text":"<p>The Additional settings in your Burp Suite extension allow you to configure the following options:</p> <code>Language</code> <p>You can select the language that will be used for encryption and decryption. It's important to note that the same language will be applied to both request and response, as well as for both encryption and decryption operations.</p> <code>Encryption Method</code> <p>This option is available only for request-related settings. You can choose the encryption method to be applied to the GET parameters, request body, or both.</p> <code>Encryption/Decryption For</code> <p>Here, you can select whether you want to perform encryption and decryption operations for the request, response, or both. Additionally, you will need to specify the request and response types to define the scope of these operations.</p>"},{"location":"Examples/#request-encryption-files","title":"Request Encryption Files","text":"<p>To encrypt and decrypt request data, you have the option to choose the encryption and decryption files. It's important to select the appropriate file based on the programming language specified in the additional settings.</p>"},{"location":"Examples/#response-encryption-files","title":"Response Encryption Files","text":"<p>For encrypting and decrypting response data, you can also select the encryption and decryption files. Make sure to choose the file that aligns with the programming language selected in the additional settings.</p>"},{"location":"Examples/#auto-encrypt","title":"Auto Encrypt","text":"<p>The auto-encryption feature enables you to encrypt requests within your Burp Suite extension. It allows you to specify the tool type for which the request should be encrypted. This functionality is particularly useful when performing automated scans, such as Burp Suite Active Scan or SQLMAP.</p> <p>When dealing with an encrypted request that needs to be scanned using the Burp Suite scanner, a challenge arises because adding any payload in plain text format to an encrypted parameter would result in the server rejecting the request. This rejection occurs because the server fails to decrypt the request on its side.</p> <p>To address this issue, you can provide the decrypted request to the scanner and activate the \"Auto Encrypt\" option. Additionally, you can select the appropriate tool type for the scanner.</p> <p>By doing so, the scanner will receive the decrypted request and add any necessary payload. Subsequently, the extension will encrypt the request (based on the selected Request Type) before the scanner sends it to the server.</p> <p>Similarly, for SQLMAP, you can supply the decrypted request and configure SQLMAP to send all requests to the Burp proxy. Make sure to enable the \"Auto Encrypt\" option in this case as well.</p>"},{"location":"Examples/#menu","title":"Menu","text":"<p>PyCript offers several additional options accessible through the right-click menu. To access these options, simply right-click on any request within Burp Suite, whether it's in Repeater, Target, Proxy, or elsewhere. In the menu that appears, you will find an \"Extensions\" option, and within that submenu, you will see \"PyCript.\"</p> <p>Upon selecting the PyCript submenu, you will be presented with three distinct options:</p> <ul> <li> <p>Decrypt Request: This option allows you to decrypt the request, enabling you to analyze its contents in its original, unencrypted form. The decrypted request will be stored in the PyCript extension for easy access. You can find it in the \"PyCript\" tab, under the \"Decrypted Request\" sub-tab.</p> </li> <li> <p>Decrypt String: With this option, you can select any data within the request and response. PyCript will then show you the decrypted version of the selected string, providing a way to analyze the decrypted data.</p> </li> <li> <p>Encrypt String: This option allows you to encrypt selected data within the request and response. PyCript will show you the encrypted version of the selected string.</p> </li> </ul> <p>Info</p> <p>When selecting a string from the request in your Burp Suite extension, the encryption/decryption script used for the request will be applied. If you have not added an encryption/decryption script specifically for the request, the script associated with the response will be utilized instead. Similarly, if you choose a string from the response, the corresponding encryption/decryption script will be used accordingly.</p>"},{"location":"Prerequisites/","title":"Prerequisites","text":""},{"location":"Prerequisites/#prerequisites","title":"Prerequisites","text":"<p>PyCript provides the flexibility to implement custom encryption and decryption algorithms using three distinct programming languages. To utilize PyCript, one must have at least one of these languages installed and properly configured in the user or system environment, enabling access from anywhere within the system.</p> <ul> <li>Python or Java or NodeJS + NPM</li> <li>Burp Suite configured with Jython to install the Python extension </li> </ul> <p>Note</p> <p>PyCript runs Python code directly without requiring the user to explicitly specify whether to use Python 2 or Python 3. It is important to ensure that the system is configured to use the desired version of Python when PyCript is executed.</p> <p>Note</p> <p>If you choose to use the Java programming language with PyCript, you will require a JAR file to be provided. Please ensure that you include the JAR file, and not the compiled class file or Java source code, when using PyCript.</p> <p>Note</p> <p>When opting to utilize JavaScript with PyCript, it's essential to ensure that all necessary libraries are present in the folder where encryption and decryption files are stored. This is particularly important as many Node.js libraries require the presence of related dependencies in the same directory.</p>"},{"location":"Scripts/","title":"Writing Custom Scripts","text":""},{"location":"Scripts/#working-of-the-extension","title":"Working of the Extension","text":"<p>The extension utilizes JavaScript/Python/Java Jar files for executing encryption and decryption operations by running system commands.</p> <pre><code>node user/provided/javascript/file/path/encryption.js -d bas64-encodeed-encrypted-request-body\n</code></pre> <pre><code>python user/provided/python/file/path/encryption.py -d bas64-encodeed-encrypted-request-body\n</code></pre> <pre><code>java -jar user/provided/java/file/path/encryption.jar -d bas64-encodeed-encrypted-request-body\n</code></pre>"},{"location":"Scripts/#command-line-argument-for-bodyparameters","title":"Command Line Argument for Body/Parameters","text":"<p>The extension utilizes the -d command line argument to pass the body or parameters to the Java/Python/JavaScript code. If you are writing a script, ensure that your script supports command line arguments with the -d flag.</p>"},{"location":"Scripts/#base64-encoding-of-d-value","title":"Base64 Encoding of -d Value","text":"<p>The value provided with the -d argument will be in base64 format. Even if your original request is already in base64, the extension will perform base64 encoding again and provide the encoded value to your code. To obtain the original value of your request body or parameter, you need to decode the base64 value in your code.</p>"},{"location":"Scripts/#base64-encoding-for-string-consistency","title":"Base64 Encoding for String Consistency","text":"<p>The extension performs base64 encoding to ensure consistency and avoid any string-related issues, such as spaces or special characters.</p>"},{"location":"Scripts/#performing-actions-and-adding-logic","title":"Performing Actions and Adding Logic","text":"<p>Your code can perform any action or add any logic to the provided value. The extension will read the output of the system command, so it is essential that your code prints the updated value accordingly.</p>"},{"location":"Scripts/#consistency-across-request-types-and-response-types","title":"Consistency Across Request Types and Response Types","text":"<p>This approach and code structure apply to all request types and response types in the extension, except for the \"Custom Request\" and \"Custom Request (Edit Header)\" types.</p>"},{"location":"Scripts/#encryption-and-decryption-code","title":"Encryption and Decryption Code","text":"<p>The same logic described above is applicable to encryption and decryption code as well. Ensure that your code follows the specified format and guidelines for encryption and decryption operations.</p>"},{"location":"Scripts/#output-format","title":"Output Format","text":"<p>The output or print statement provided by your code will be read by the extension, and it should be in the original format, not in base64. Make sure your code returns the result in the expected format.</p> <p>Warning</p> <p>There should not be more than one print statement or output in your code. The extension relies on reading the system command output, so having multiple print statements or outputs can cause unexpected behavior.</p> PythonJavaScriptJava <pre><code>import parser\nfrom base64 import b64decode\n\nparser = argparse.ArgumentParser(description='Process data argument')\nparser.add_argument('-d', '--data', help='Input data')\n\nargs = parser.parse_args()\nciphertext = b64decode(args.data).decode('utf-8')\n\n## Your encryption logic\n\nprint(output)\n</code></pre> <pre><code>const program = require(\"commander\");\nconst { Buffer } = require('buffer');\n\nprogram\n  .option(\"-d, --data &lt;data&gt;\", \"Data to process\")\n  .parse(process.argv);\n\nconst options = program.opts();\nconst requestbody = Buffer.from(options.data, 'base64').toString('utf8');\n\n'Your encryption and decryption logic should be here'\n\nconsole.log(Output)\n</code></pre> <pre><code>import java.util.Base64;\n\npublic class AESCBC128Decrypt {\n\npublic static void main(String[] args) {\n    String base64Ciphertext = args[1];\n\n    try {\n        String ciphertext = new String(Base64.getDecoder().decode(base64Ciphertext), StandardCharsets.UTF_8);\n\n        /// You encryption decryption logic\n\n        System.out.println(output);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n\n}}\n</code></pre>"},{"location":"Scripts/#custom-request-type","title":"Custom Request Type","text":"<p>When implementing the Custom Request feature in your Burp Suite extension, there are a few changes to consider in your code. The points mentioned earlier in the documentation will still apply, but with the addition of some further details. Custom Request will have additional command line arguments as -h that will allow you to read the request header as well.</p> <pre><code>node user/provided/javascript/file/path/encryption.js -d bas64-encodeed-encrypted-request-body -h W1BPU1QgL2NyeXB0by91c2VyLyBIVFRQLzEuMSwgSG9zdDogbG9jYWxob3N0OjgwMDAsIEtleTogMTIzNCwgSXY6IDEyMzRd\n</code></pre> <pre><code>python user/provided/python/file/path/encryption.py -d bas64-encodeed-encrypted-request-body -h W1BPU1QgL2NyeXB0by91c2VyLyBIVFRQLzEuMSwgSG9zdDogbG9jYWxob3N0OjgwMDAsIEtleTogMTIzNCwgSXY6IDEyMzRd\n</code></pre> <pre><code>java -jar user/provided/java/file/path/encryption.jar -d bas64-encodeed-encrypted-request-body -h W1BPU1QgL2NyeXB0by91c2VyLyBIVFRQLzEuMSwgSG9zdDogbG9jYWxob3N0OjgwMDAsIEtleTogMTIzNCwgSXY6IDEyMzRd\n</code></pre> <p>The custom request functionality remains unchanged, with the addition of the -h flag to include the request header in a list/array format. Unlike the -d flag, the -h flag does not contain any Base64-encoded data.</p> <p>Warning</p> <p>From the PyCript version 0.3 -h flag will be provided in base64 encoded format same as -d flag. Make sure to modify the script to handle the same. </p> <pre><code>[POST /crypto/myprofile/ HTTP/1.1, Host: localhost:8000, Accept-Encoding: gzip, deflate, Accept: */*, Accept-Language: en-US;q=0.9,en;q=0.8, User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36, Connection: close, Key: 1234, Iv: 1234, Cache-Control: max-age=0, Content-Type: application/x-www-form-urlencoded, Content-Length: 24]\n</code></pre> PythonJavaScriptJava <pre><code>import argparse\nfrom base64 import b64decode\n\nparser = argparse.ArgumentParser(description='Process data argument',add_help=False)\nparser.add_argument('-d', '--data', help='Input data')\nparser.add_argument('-h', '--header', help='header data')\n\n\nargs = parser.parse_args()\nciphertext = b64decode(args.data).decode('utf-8')\nheader = 64decode(args.header).decode('utf-8')\n\n## Your encryption logic\n\nprint(output)\n</code></pre> <pre><code>const program = require(\"commander\");\nconst { Buffer } = require('buffer');\n\nprogram\n  .option(\"-d, --data &lt;data&gt;\", \"Data to process\")\n  .option(\"-h, --header &lt;data&gt;\", \"Header\")\n  .parse(process.argv);\n\nconst options = program.opts();\nconst requestbody = Buffer.from(options.data, 'base64').toString('utf8');\nconst header = Buffer.from(options.header, 'base64').toString('utf8');\n\n'Your encryption and decryption logic should be here'\n\nconsole.log(Output)\n</code></pre> <pre><code>import java.util.Base64;\n\npublic class AESCBC128Decrypt {\n\npublic static void main(String[] args) {\n\n\n  for (int i = 0; i &lt; args.length; i++) {\n        if (\"-d\".equals(args[i])) {\n            base64Ciphertext = args[i + 1];\n        }\n        if (\"-h\".equals(args[i])) {\n            String headerbase64 = args[i + 1];\n        }\n    }\n\n    try {\n        String ciphertext = new String(Base64.getDecoder().decode(base64Ciphertext), StandardCharsets.UTF_8);\n        String header = new String(Base64.getDecoder().decode(headerbase64), StandardCharsets.UTF_8);\n\n        /// You encryption decryption logic\n\n        System.out.println(output);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n\n}}\n</code></pre> <p>Warning</p> <p>Given the limitation of only being able to read the header, it is important to ensure that you only print the output of the encryption/decryption process and not the header. </p>"},{"location":"Scripts/#custom-request-edit-headers","title":"Custom Request (Edit Headers)","text":"<p>Custom Request and Custom Request (Edit Header) have several similarities with a few key differences:</p> <ol> <li> <p>In Custom Request (Edit Header), the value of the -h parameter is also base64 encoded, unlike the plain text value in Custom Request.</p> </li> <li> <p>The -h value in Custom Request is in a list/array format, whereas in Custom Request (Edit Header), the header is in raw format, just as you would see it in Burp Suite.</p> </li> <li> <p>Since Custom Request (Edit Header) allows for header editing, it's necessary to print the header as well, but in base64 format.</p> </li> <li> <p>For all types, pycript will pass the -d parameter for the body/parameter in base64 format.</p> </li> <li> <p>The output of the encrypted/decrypted string/body will also be in base64 format.</p> </li> <li> <p>It is important to print the base64 header first, followed by the base64 body/parameter.</p> </li> <li> <p>Since the header is in raw format, you can split it using new line characters (\\n) to edit or add new headers.</p> </li> <li> <p>When printing the updated header in base64, it should retain the same raw format. If you split the header with new line characters to make changes, you will need to join it again to restore it to the original raw format.</p> </li> </ol> <pre><code>node user/provided/javascript/file/path/encryption.js -d bas64-encodeed-encrypted-request-body -h UE9TVCAvYXBpL2dldHVzZXI0IEhUVFAvMS4xCkhvc3Q6IDEyNy4wLjAuMTo4MDAwCkFjY2VwdC1FbmNvZGluZzogZ3ppcCwgZGVmbGF0ZQpBY2NlcHQ6ICovKgpTaWduYXR1cmU6IDA4NjFjMDBiODFlNWY2OTZkNGE5MjM3MGE4OTYxYzEyCkFjY2VwdC1MYW5ndWFnZTogZW4tVVM7cT0wLjksZW47cT0wLjgKVXNlci1BZ2VudDogTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEwMy4wLjUwNjAuMTM0IFNhZmFyaS81MzcuMzYKQ29ubmVjdGlvbjogY2xvc2UKQ2FjaGUtQ29udHJvbDogbWF4LWFnZT0wCkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbgpDb250ZW50LUxlbmd0aDogMzg=\n</code></pre> <pre><code>python user/provided/python/file/path/encryption.py -d bas64-encodeed-encrypted-request-body -h UE9TVCAvYXBpL2dldHVzZXI0IEhUVFAvMS4xCkhvc3Q6IDEyNy4wLjAuMTo4MDAwCkFjY2VwdC1FbmNvZGluZzogZ3ppcCwgZGVmbGF0ZQpBY2NlcHQ6ICovKgpTaWduYXR1cmU6IDA4NjFjMDBiODFlNWY2OTZkNGE5MjM3MGE4OTYxYzEyCkFjY2VwdC1MYW5ndWFnZTogZW4tVVM7cT0wLjksZW47cT0wLjgKVXNlci1BZ2VudDogTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEwMy4wLjUwNjAuMTM0IFNhZmFyaS81MzcuMzYKQ29ubmVjdGlvbjogY2xvc2UKQ2FjaGUtQ29udHJvbDogbWF4LWFnZT0wCkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbgpDb250ZW50LUxlbmd0aDogMzg=\n</code></pre> <pre><code>java -jar user/provided/java/file/path/encryption.jar -d bas64-encodeed-encrypted-request-body -h UE9TVCAvYXBpL2dldHVzZXI0IEhUVFAvMS4xCkhvc3Q6IDEyNy4wLjAuMTo4MDAwCkFjY2VwdC1FbmNvZGluZzogZ3ppcCwgZGVmbGF0ZQpBY2NlcHQ6ICovKgpTaWduYXR1cmU6IDA4NjFjMDBiODFlNWY2OTZkNGE5MjM3MGE4OTYxYzEyCkFjY2VwdC1MYW5ndWFnZTogZW4tVVM7cT0wLjksZW47cT0wLjgKVXNlci1BZ2VudDogTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEwMy4wLjUwNjAuMTM0IFNhZmFyaS81MzcuMzYKQ29ubmVjdGlvbjogY2xvc2UKQ2FjaGUtQ29udHJvbDogbWF4LWFnZT0wCkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbgpDb250ZW50LUxlbmd0aDogMzg=\n</code></pre> PythonJavaScriptJava <pre><code>import argparse\nfrom base64 import b64decode\n\nparser = argparse.ArgumentParser(description='Process data argument',add_help=False)\nparser.add_argument('-d', '--data', help='Input data')\nparser.add_argument('-h', '--header', help='header data')\n\n\nargs = parser.parse_args()\nciphertext = b64decode(args.data).decode('utf-8')\nheader = b64decode(args.header).decode('utf-8')\n\n## Your encryption logic\n## Update the header\n\n## print the heeader first then bod\nprint(b64encode(updated_header))\nprint(b64encode(updatedbody))\n</code></pre> <pre><code>const program = require(\"commander\");\nconst { Buffer } = require('buffer');\n\nprogram\n  .option(\"-d, --data &lt;data&gt;\", \"Data to process\")\n  .option(\"-h, --header &lt;data&gt;\", \"Header\")\n  .parse(process.argv);\n\nconst options = program.opts();\nconst requestbody = Buffer.from(options.data, 'base64').toString('utf8');\nconst header = Buffer.from(options.header, 'base64').toString('utf8');\n\n'Your encryption and decryption logic should be here'\n'Updated the header'\n\n\n// printt the updated base64 header and updated base64 body\nconsole.log(Buffer.from(updatedheader).toString('base64'));\nconsole.log(Buffer.from(updatedbody).toString('base64'));\n</code></pre> <pre><code>import java.util.Base64;\n\npublic class AESCBC128Decrypt {\n\npublic static void main(String[] args) {\n\n\n  for (int i = 0; i &lt; args.length; i++) {\n        if (\"-d\".equals(args[i])) {\n            base64Ciphertext = args[i + 1];\n        }\n        if (\"-h\".equals(args[i])) {\n            String base64Header = args[i + 1];\n        }\n    }\n\n    try {\n        String ciphertext = new String(Base64.getDecoder().decode(base64Ciphertext), StandardCharsets.UTF_8);\n        // Decode the Base64 header\n        byte[] decodedHeader = Base64.getDecoder().decode(base64Header);\n        String rawHeader = new String(decodedHeader, StandardCharsets.UTF_8);\n\n        /// You encryption decryption logic\n\n        String updatedHeaderBase64Body = Base64.getEncoder().encodeToString(updatedHeader.getBytes(StandardCharsets.UTF_8));\n        String updatedBase64Body = Base64.getEncoder().encodeToString(updatedBody.getBytes(StandardCharsets.UTF_8));\n        System.out.println(updatedHeaderBase64Body);\n        System.out.println(updatedBase64Body);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n\n}}\n</code></pre>"},{"location":"Scripts/#debug","title":"Debug","text":"<p>If you encounter difficulties decrypting or encrypting the request within the extension, it is important to ensure that your code is functioning correctly. To encrypt or decrypt the request body or string, you can follow these steps: </p> <ol> <li>Base64 encode the value you wish to encrypt or decrypt.</li> <li>Execute the same command in your terminal or CMD.</li> </ol> <p>By performing these steps, you can verify the functionality of the encryption or decryption process outside of the extension environment.</p>"},{"location":"Scripts/#demo-code","title":"Demo Code","text":"<p>If you are looking for demo encryption decryption code for common type of encryption or logic you can get it from the PyCript Template</p>"},{"location":"installation/","title":"Installation","text":"<p>Warning</p> <p>Please make sure that all the prerequisites mentioned are installed first.</p>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<ul> <li>Download the PyCript repository from GitHub either by cloning the repository using  <code>git clone https://github.com/Anof-cyber/PyCript</code> or by downloading the repository as a zip file.</li> <li>Extract the contents of the zip file if you downloaded the repository as a zip file.</li> <li>Open Burp Suite, and navigate to the \"Extender\" tab.</li> <li>Click on the \"Add\" button to add a new extension.</li> <li>In the \"Extension Type\" field, select \"Python\"</li> <li>Click on the \"Select file\" button and browse to the location of the \"pycript.py\" file, which should be located in the PyCript repository that you downloaded.</li> <li>Click on the \"Open\" button to load the PyCript extension into Burp Suite.</li> <li>The PyCript extension should now be listed under the \"Extensions\" tab in Burp Suite, and you can use its features.</li> </ul>"},{"location":"installation/#burp-suite-bapp-store-installation","title":"Burp Suite BApp Store Installation","text":"<p>Info</p> <p>The extension is not available on the Burp Suite BApp Store.</p>"},{"location":"workflow/","title":"Workflow","text":""},{"location":"workflow/#flow-of-the-extension","title":"Flow of the Extension","text":"<p>PyCript utilizes the system command to run encryption and decryption scripts that are specified by the user. Depending on the chosen configuration, the extension acquires request data such as the body, string, parameters, headers, and so on, and then transfers the information to the designated user file (Python, NodeJS, or Java). Once the command has been executed, the extension anticipates the output of the command, which should be either encrypted or decrypted data. The extension then proceeds to read the command output and make adjustments to the request/response within Burp Suite.</p>"},{"location":"workflow/#commands","title":"Commands","text":"<p>The PyCript extension executes two distinct commands depending on the user's selected configuration. The following commands are available:</p> Body and ParametersBody and Headers <ul> <li>node script.js -d base64-encoded-data</li> <li>python script.py -d base64-encoded-data</li> <li>java -jar script.jar -d base64-encoded-data</li> </ul> <p>Note</p> <p>When using the -d option in PyCript, the data is provided in base64 encoded format to prevent errors that may occur due to special characters. Make sure to decode the value in your script.</p> <p>Based on the configuration provided, this extension will offer different values for the -d option.</p> <ul> <li>Complete Body - The extension will take the request/response body and will pass the value to script with -d </li> <li> <p>Paramter Value - PyCript is designed to iterate through the request/response parameter values and pass each value to a script with the -d flag. It will then update each value one by one.</p> </li> <li> <p>Paramter key and value - The PyCript extension adopts a similar approach to that of parameter value. It iterates through each parameter name and value, passing them one by one to the script for updating.</p> </li> </ul> <ol> <li>Read Headers<ul> <li>node script.js -d base64-encoded-data -h ['GET / http/1.1','Host: localhost']</li> <li>python script.py -d base64-encoded-data -h ['GET / http/1.1','Host: localhost']</li> <li>java -jar script.jar -d base64-encoded-data -h ['GET / http/1.1','Host: localhost']</li> </ul> </li> <li>Edit Headers<ul> <li>node script.js -d base64-encoded-data -h base64-encoded-raw-headers</li> <li>python script.py -d base64-encoded-data -h base64-encoded-raw-headers</li> <li>java -jar script.jar -d base64-encoded-data -h base64-encoded-raw-headers</li> </ul> </li> </ol> <p>PyCript offers two methods to work with headers. The first method enables you to read headers in your script, which is useful if your application sends the encryption key or initialization vector (IV) in the header and each request has a different key or IV. However, this method does not allow you to update the header. The extension expects the script to only return the updated data of the -d flag. Additionally, the -h flag will have plain text data but in a list/array format provided by Burp APIs.</p> <p>The second method allows you to update the headers as well and can be useful where some application implementat the singaure verification in headers that store the signaure like hash of the request body and won't allow you edit the paramter as signature mismach.</p>"},{"location":"workflow/#usage","title":"Usage","text":"<ul> <li>Start by loading the PyCript extension into Burp Suite.</li> <li>Choose the language you want to use for encryption and decryption.</li> <li>Load the encryption and decryption file.</li> <li>Decide whether you want to apply encryption and decryption to the request, response, or both, and select the appropriate type.</li> <li>For request encryption and decryption, specify the method you want to use (GET, BODY, or Both).</li> <li>Make sure the URL you want to work with is within the scope of Burp Suite.</li> <li>Once you've located the encrypted request or response, a new PyCript tab will be generated next to it, with a plaintext version that you can edit as needed.</li> </ul>"},{"location":"workflow/#parameters","title":"Parameters","text":"<p>It is important to verify the supported request parameters or content types by PyCript. The following methods encompass the content types and parameters supported by PyCript:</p> Body ParametersJSON <p>The PyCript extension leverages the APIs offered by Burp Suite to examine get and body parameters. However, there may be situations where its performance is suboptimal when faced with encrypted or encoded parameters containing multiple <code>=</code> characters. If you encounter challenges in parsing such requests, it is recommended to use the complete body or custom request options and incorporate customized parsing into your script.</p> <pre><code>POST /crypto/myprofile?username=KtKB81Oamvuzo9entPFKZQ%3d%3d&amp;password=KtKB81Oamvuzo9entPFKZQ%3d%3d HTTP/1.1\nHost: localhost:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 24\n\nusername=KtKB81Oamvuzo9entPFKZQ%3d%3d&amp;password=KtKB81Oamvuzo9entPFKZQ%3d%3d\n</code></pre> <p>PyCript has included JSON support since its initial release. The extension utilizes custom parsing methods to handle JSON objects, as Burp Suite itself does not natively support direct manipulation of JSON objects. Starting from version 0.2, PyCript extends its support to handle nested and complex JSON objects.</p> <pre><code>POST /crypto/login/ HTTP/1.1\nHost: localhost:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 77\n\n{\"username\":\"HgE40uCnUDbOfuat6om5QA==\",\"password\":\"FZbf3I/h9ORUV+H6Wzv4gA==\"}\n</code></pre> <p>Info</p> <p>The current extension does not offer direct support for parsing multipart requests for parameters. However, you have the option to manually parse the request body using either the complete body or a custom request method within your script.</p>"}]}