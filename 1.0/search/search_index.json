{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The Pycript extension for Burp Suite is a valuable tool for penetration testing and security professionals. It enables easy encryption and decryption of requests during testing, which can help evade detection and bypass security measures. The extension also offers the ability to customize the encryption and decryption process by writing custom logic using JavaScript and Node.js, making it a highly adaptable tool for various needs. Additionally, it supports both manual and automated testing, as well as custom encryption/decryption plugins, making it a versatile solution for different penetration testing scenarios.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ability to decrypt requests and modify data in real-time</li> <li>Provides JavaScript and NodeJS support for custom encryption and decryption logic.</li> <li>The ability to retrieve the encryption key and IV directly from the request header and body using Burpsuite and JavaScript.</li> <li>Supports decryption of multiple requests </li> <li>Use auto-encryption to perform an automated burp scan or sqlmap</li> </ul>"},{"location":"#sponsor","title":"Sponsor","text":""},{"location":"#team","title":"Team","text":""},{"location":"#sourav-kalal","title":"Sourav Kalal","text":""},{"location":"#documentation","title":"Documentation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#select-language","title":"Select Language","text":""},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#writing-custom-scripts","title":"Writing Custom Scripts","text":""},{"location":"#video","title":"Video","text":""},{"location":"Examples/","title":"Usage Examples","text":""},{"location":"Examples/#config","title":"Config","text":"<p>The configuration tab contains all the necessary settings to enable encryption and decryption functionality. Within the configuration, you can select whether to apply encryption and decryption to requests, responses, or both. Additionally, you can specify the preferred programming language and load any necessary encryption/decryption files, among other options.</p> <p>Warning</p> <p>This extension is designed to operate exclusively on URLs that have been included within the target scope of Burp Suite.</p> <p>Warning</p> <p>PyCript version 0.4 change the use of encrpytion decryption langague as well how it pass data to the encrpytion decryption script over command line argmunet. Older script will not work with new PyCript. Check the \"Select Language\" and \"Writing Custom Scripts\" page.</p>"},{"location":"Examples/#request-type","title":"Request Type","text":"<p>The Request Type feature enables you to choose the specific request or message type that requires encryption or decryption.</p> Complete BodyParameter ValueParameter Key and ValueCustom RequestCustom Request Edit Header <p>The \"Complete Body\" option within the request type of your Burp Suite extension offers valuable functionality in various scenarios. It proves useful when the entire request body is encrypted, or when the body contains encrypted data along with key/iv within it. Additionally, this option is beneficial if you desire to implement custom parsing of the request body through a script of your choice.</p> <p>By selecting the \"Complete Body\" option, Pycript will take the entire request body and pass it to the encryption and decryption script provided by the user. This allows for seamless integration of your own encryption and decryption logic with Burp Suite.</p> Example 1Example 2 <pre><code>POST /api/getuser HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 24\n\nAEIwJOtaQXdO9qzIJFIhEQ==\n</code></pre> <p></p> <p><pre><code>POST /api/getuser2 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 88\n\n{\"user_id\": \"W12wkCO+v4IOkEN3ENbRNQ==\",\"key\":\"mysecretkey12345\",\"iv\":\"n2r5u8x/A%D*G-Ka\"}\n</code></pre> </p> <p>When dealing with multiple parameters, where only the parameter values are encrypted, the parameter value can be retrieved from query parameters, JSON values, or body parameters. The PyCript module handles this process by passing one parameter value at a time to the user-provided script. The complete body or parameters are not passed to the script.</p> Example 1Example 2Example 3 <p><pre><code>POST /api/getuser2 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 39\n\n{\"user_id\": \"kmcduz+eWvqNbPAq//UQGA==\"}\n</code></pre> </p> <pre><code>GET /api/getuser5?user_id=W12wkCO+v4IOkEN3ENbRNQ== HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\n</code></pre> <p></p> <pre><code>POST /api/getuser5?user_id=kmcduz+eWvqNbPAq//UQGA== HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 39\n\n{\"user_id\": \"kmcduz+eWvqNbPAq//UQGA==\"}\n</code></pre> <p></p> <p>The Parameter Key and Value method proves to be valuable when dealing with encrypted parameter names and values in an application. By utilizing Pycript, the extension follows a consistent process of combining each parameter and its corresponding value. Subsequently, it proceeds to individually pass each resulting string to the encryption and decryption script.</p> Example 1 <pre><code>POST /api/getuser3 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 56\n\n{\"elHLzVxVH4e3AayiZkfB9g==\": \"W12wkCO+v4IOkEN3ENbRNQ==\"}\n</code></pre> <p></p> <p>The custom request feature is valuable for executing specific actions using scripts. It proves particularly helpful in scenarios where the request body is encrypted, and the encryption key or initialization vector (IV) is stored in the header. In such cases, the \"Complete Body\" option cannot be used.</p> <p>When utilizing the Custom Request type, both the request body and header are passed to the script for encryption and decryption purposes. This functionality enables you to access and analyze the headers while performing the necessary encryption or decryption operations.</p> Example 1 <pre><code>POST /api/getuser HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nKey: mysecretkey12345\nIv: n2r5u8x/A%D*G-Ka\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 24\n\nAEIwJOtaQXdO9qzIJFIhEQ==\n</code></pre> <p></p> <p>The \"Custom Request Edit Header\" feature was introduced in version 0.2 of the Burp Suite extension. It provides the capability to modify the request header. This functionality is not limited to editing alone; you can also add or delete headers as needed. It proves to be particularly useful in applications where data modification is restricted through various proxy or validation mechanisms, such as adding a signature to request parameters or body and enforcing signature verification to prevent any value modification.</p> Example 1 <pre><code>POST /api/getuser4 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nSignature: 7d1b73091d0f089a3a790af24404f6b4\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 39\n\n{\"user_id\": \"W12wkCO+v4IOkEN3ENbRNQ==\"}\n</code></pre> <p></p>"},{"location":"Examples/#response-type","title":"Response Type","text":"<p>The Response Type feature enables you to choose the specific response or message type that requires encryption or decryption.</p> <p>Warning</p> <p>The encryption and decryption of responses were introduced in PyCript v0.2. Please note that this functionality is currently limited to JSON response content types.</p> <p>Info</p> <p>If your complete response body is encrypted and there are possibilities that body will be in double/single quotes. You need to handle the same in your script.</p> <p>Info</p> <p>The Response Type in your Burp Suite extension mirrors the functionality of the request type. In fact, you can utilize the same script for both request and response actions, with the exception of the Custom Request and Custom Request (Edit Header) options.</p>"},{"location":"Examples/#additional-setting","title":"Additional Setting","text":"<p>The Additional settings in your Burp Suite extension allow you to configure the following options:</p> <code>Language</code> <p>You can select the language that will be used for encryption and decryption. It's important to note that the same language will be applied to both request and response, as well as for both encryption and decryption operations.</p> <code>Encryption Method</code> <p>This option is available only for request-related settings. You can choose the encryption method to be applied to the GET parameters, request body, or both.</p> <code>Encryption/Decryption For</code> <p>Here, you can select whether you want to perform encryption and decryption operations for the request, response, or both. Additionally, you will need to specify the request and response types to define the scope of these operations.</p>"},{"location":"Examples/#request-encryption-files","title":"Request Encryption Files","text":"<p>To encrypt and decrypt request data, you have the option to choose the encryption and decryption files. It's important to select the appropriate file based on the programming language specified in the additional settings.</p>"},{"location":"Examples/#response-encryption-files","title":"Response Encryption Files","text":"<p>For encrypting and decrypting response data, you can also select the encryption and decryption files. Make sure to choose the file that aligns with the programming language selected in the additional settings.</p>"},{"location":"Examples/#auto-encrypt","title":"Auto Encrypt","text":"<p>The auto-encryption feature enables you to encrypt requests within your Burp Suite extension. It allows you to specify the tool type for which the request should be encrypted. This functionality is particularly useful when performing automated scans, such as Burp Suite Active Scan or SQLMAP.</p> <p>When dealing with an encrypted request that needs to be scanned using the Burp Suite scanner, a challenge arises because adding any payload in plain text format to an encrypted parameter would result in the server rejecting the request. This rejection occurs because the server fails to decrypt the request on its side.</p> <p>To address this issue, you can provide the decrypted request to the scanner and activate the \"Auto Encrypt\" option. Additionally, you can select the appropriate tool type for the scanner.</p> <p>By doing so, the scanner will receive the decrypted request and add any necessary payload. Subsequently, the extension will encrypt the request (based on the selected Request Type) before the scanner sends it to the server.</p> <p>Similarly, for SQLMAP, you can supply the decrypted request and configure SQLMAP to send all requests to the Burp proxy. Make sure to enable the \"Auto Encrypt\" option in this case as well.</p>"},{"location":"Examples/#menu","title":"Menu","text":"<p>PyCript offers several additional options accessible through the right-click menu. To access these options, simply right-click on any request within Burp Suite, whether it's in Repeater, Target, Proxy, or elsewhere. In the menu that appears, you will find an \"Extensions\" option, and within that submenu, you will see \"PyCript.\"</p> <p>Upon selecting the PyCript submenu, you will be presented with three distinct options:</p> <ul> <li> <p>Decrypt Request: This option allows you to decrypt the request, enabling you to analyze its contents in its original, unencrypted form. The decrypted request will be stored in the PyCript extension for easy access. You can find it in the \"PyCript\" tab, under the \"Decrypted Request\" sub-tab.</p> </li> <li> <p>Decrypt String: With this option, you can select any data within the request and response. PyCript will then show you the decrypted version of the selected string, providing a way to analyze the decrypted data.</p> </li> <li> <p>Encrypt String: This option allows you to encrypt selected data within the request and response. PyCript will show you the encrypted version of the selected string.</p> </li> </ul> <p></p> <p>Info</p> <p>When selecting a string from the request in your Burp Suite extension, the encryption/decryption script used for the request will be applied. If you have not added an encryption/decryption script specifically for the request, the script associated with the response will be utilized instead. Similarly, if you choose a string from the response, the corresponding encryption/decryption script will be used accordingly.</p>"},{"location":"Prerequisites/","title":"Prerequisites","text":""},{"location":"Prerequisites/#prerequisites","title":"Prerequisites","text":"<p>PyCript provides the flexibility to implement custom encryption and decryption algorithms using any programming language. To utilize PyCript, one must have a compiled binary of the custom encryption and decryption code with Windows PE or Mach-O etc or the language to run the script or executable like Go, Python, Nodejs etc.</p> <ul> <li>Burp Suite configured with Jython to install the Python extension </li> </ul> <p>Note</p> <p>PyCript v1.0 change the working of the extension, the older script of encryption and decryption will not work with version 1.0</p> <p>Note</p> <p>If you choose to use the Java programming language with PyCript, you will require a JAR file to be provided. Please ensure that you include the JAR file, and not the compiled class file or Java source code, when using PyCript.</p> <p>Note</p> <p>When opting to utilize JavaScript with PyCript, it's essential to ensure that all necessary libraries are present in the folder where encryption and decryption files are stored. This is particularly important as many Node.js libraries require the presence of related dependencies in the same directory as node_modules.</p>"},{"location":"Scripts/","title":"Writing Custom Scripts","text":""},{"location":"Scripts/#working-of-the-extension","title":"Working of the Extension","text":"<p>The extension utilizes user provided encrpyption decrpytion files for executing encryption and decryption operations by running system commands.</p> <p>Warning</p> <p>PyCript before version 0.4 used to pass encrpyted paramter/body etc over -d argument in bass64 format and -h for header in base64 format. from version 0.4 there will be not -h argument, also -d will not have parameter/body.Check issue for more details</p> <p>PyCript expect user to provide encryption decryption code file, the code langauge could be anything Like Python, Java, JavaScript, Go, Bash script, Powershell script, C/C++ or Any. Check Select Language page for more details.</p> <p>Info</p> <p>From PyCript version 0.4 you can use any language for encryption decryption as long as it uses the format of PyCript to read data and pass data to and from PyCript.</p> <p>Info</p> <p>Check the Dummy Code repository PyCript Template Has example codes in  Python, Go, Bash, Powershell, JavaScript and Java</p> <p>PyCript run system command to execute the script or binary provided for encryption and decryption. User is suppose to provide the language path. Check Select Language page for more details.</p> <p>Next user is suppose to provide the encrpytion decrpytion file path. Later based on the setting on PyCript config tab, the extension will provided the encrpyted decrpyted body/paramter/header to the script.</p> <p>The extension will take the encrypted/plaintext parameter/body create a temp file in the OS and add the encrypted/plaintext parameter/body in the temp file JSON format. The data will be base64 encoded by extension to avoid special characters.</p> <pre><code>{\"data\":\"cGxhaW50ZXh0\"}\n</code></pre> <pre><code>/user/path/to/language/like/node user/file/path/encryption.js -d temp-file-path\n</code></pre>"},{"location":"Scripts/#command-line-argument-for-bodyparameters","title":"Command Line Argument for Body/Parameters","text":"<p>The extension utilizes the -d command line argument to pass the full path of the temp file storing the body or parameters to the encryption/decryption code. If you are writing a script, ensure that your script supports command line arguments with the -d flag.</p>"},{"location":"Scripts/#base64-encoding-in-temp-file-json","title":"Base64 Encoding in temp file JSON","text":"<p>The value provided with the -d argument will be the path of the temp file. The temp file will have a JSON format where <code>data</code> key in the JSON will store the parameter/body in base64 format. Even if your original request is already in base64, the extension will perform base64 encoding again and provide the encoded value to your code. To obtain the original value of your request body or parameter, you need to decode the base64 value in your code.</p>"},{"location":"Scripts/#base64-encoding-for-string-consistency","title":"Base64 Encoding for String Consistency","text":"<p>The extension performs base64 encoding to ensure consistency and avoid any string-related issues, such as spaces or special characters.</p>"},{"location":"Scripts/#performing-actions-and-adding-logic","title":"Performing Actions and Adding Logic","text":"<p>Your code can perform any action or add any logic to the provided value. The extension will read the output of the system command, so it is essential that your code prints the updated value accordingly.</p>"},{"location":"Scripts/#consistency-across-request-types-and-response-types","title":"Consistency Across Request Types and Response Types","text":"<p>This approach and code structure apply to all request types and response types in the extension, except for the \"Custom Request\" and \"Custom Request (Edit Header)\" types.</p>"},{"location":"Scripts/#encryption-and-decryption-code","title":"Encryption and Decryption Code","text":"<p>The same logic described above is applicable to encryption and decryption code as well. Ensure that your code follows the specified format and guidelines for encryption and decryption operations.</p>"},{"location":"Scripts/#output-format","title":"Output Format","text":"<p>The output or print statement provided by your code will be read by the extension, and it should be in the original format, not in base64 except for \"Custom Request (Edit Header)\". Make sure your code returns the result in the expected format.</p> <p>Warning</p> <p>There should not be more than one print statement or output in your code. The extension relies on reading the system command output, so having multiple print statements or outputs can cause unexpected behavior.</p> PythonJavaScriptJava <pre><code>import argparse\nfrom base64 import b64decode,b64encode\nimport json\n\n# Create an argument parser\nparser = argparse.ArgumentParser(description='Process data argument')\nparser.add_argument('-d', '--data', help='File path with plaintext data + base64 in JSON format')\n\n# Parse the arguments\nargs = parser.parse_args()\n\n## Read the temp file from -d path\nwith open(args.data, 'r') as file:\n    content = json.load(file)\n\n# get the data key from the JSON    \ncihper_or_plaintext_in_base64 = content.get(\"data\")\n\n# Base64 decode to the original data \ncihper_or_plaintext = b64decode(cihper_or_plaintext_in_base64).decode('utf-8')\n\n\n## Your encryption logic\n\nprint(output)\n</code></pre> <pre><code>const fs = require('fs');\nconst path = require('path');\nvar CryptoJS = require(\"crypto-js\");\nconst { program } = require('commander');\nconst { Buffer } = require('buffer');\n\nprogram\n.option('-d, --data &lt;file_path&gt;', 'Path to JSON file containing base64 encoded + encrypted data');\n\nprogram.parse(process.argv);\nconst options = program.opts();\n\n// Read the -d value\nconst filePath = options.data;\n\n// reolve the full of -d provided path to avoid error in reading file.\nconst absoluteFilePath = path.resolve(filePath);\n\n// read the file.\nvar data = fs.readFileSync(absoluteFilePath).toString();\n\n//parse the json from the file\nconst jsonData = JSON.parse(data);\n\n// get the JSON data key value\nconst base64Data = jsonData.data; \n\n// base64 decode the value to get original data.\nconst plaintext = Buffer.from(base64Data, 'base64').toString('utf8');\n\n///Your encryption logic here\n\n// print the output\nconsole.log(output)\n</code></pre> <pre><code>import org.json.JSONObject;   //https://github.com/stleary/JSON-java\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.util.Base64;\n\npublic class AESCBC128Decrypt {\n\npublic static void main(String[] args) {\n\n    // Validate if -d is there or not\n    if (args.length != 2 || !args[0].equals(\"-d\")) {\n        System.out.println(\"Usage: java AESCBCDecrypt -d cipher-data-file-path\");\n        return;\n    }\n\n    // get -d value for temp file path\n    String ciphertextfilepath = args[1];\n    String base64Data = null;\n\n    // read the file content\n    try (FileReader reader = new FileReader(ciphertextfilepath)) {\n        // parse the file content as JSON\n        JSONObject jsonObject = new JSONObject(reader);\n\n        // parse JSON and get Data key from JSON Object\n        base64Data = (String) jsonObject.get(\"data\");\n\n    } catch (IOException  e) {\n        System.err.println(\"Error reading JSON file: \" + e.getMessage());\n    };\n    // base64 decode the value to get original data.\n    String cipher_plain_text = new String(Base64.getDecoder().decode(base64Data), StandardCharsets.UTF_8);\n\n    ///Your encryption logic here\n\n    // print the output\n    System.out.println(output);\n\n}}\n</code></pre>"},{"location":"Scripts/#custom-request-type","title":"Custom Request Type","text":"<p>When implementing the Custom Request feature in your Burp Suite extension, there are a few changes to consider in your code. The points mentioned earlier in the documentation will still apply but with the addition of some further details. Custom Request will have the headers as an array/list in base64 format in the JSON temp file as <code>header</code> key that will allow you to read the request header as well. The temp file will have content like below.</p> <p><pre><code>{\n  \"data\": \"cGxhaW50ZXh0\",\n  \"header\": \"W1BPU1QgL2NyeXB0by91c2VyLyBIVFRQLzEuMSwgSG9zdDogbG9jYWxob3N0OjgwMDAsIEtleTogMTIzNCwgSXY6IDEyMzRd\"\n}\n</code></pre> The <code>data</code> will have same encrpyted/plain text body/parameter and header will have request header in list format, Both will be base64 encoded by PyCript to get original data you have to decode both. </p> <p>The header will be in list format so if you base64 decode header it will be in a list/array format as below:</p> <p><pre><code>[POST /crypto/myprofile/ HTTP/1.1, Host: localhost:8000, Accept-Encoding: gzip, deflate, Accept: */*, Accept-Language: en-US;q=0.9,en;q=0.8, User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36, Connection: close, Key: 1234, Iv: 1234, Cache-Control: max-age=0, Content-Type: application/x-www-form-urlencoded, Content-Length: 24]\n</code></pre> The encryption/decryption code will be the same as above with you having the headers as key in the JSON, You can use the above script as well as an extension to give you a header but only expect an updated parameter/body, not the headers so you can use the above script as well as it's up to you to read the header as well if needed.</p> PythonJavaScriptJava <pre><code>import argparse\nfrom base64 import b64decode,b64encode\nimport json\n\n# Create an argument parser\nparser = argparse.ArgumentParser(description='Process data argument')\nparser.add_argument('-d', '--data', help='File path with plaintext data + base64 in JSON format')\n\n# Parse the arguments\nargs = parser.parse_args()\n\n## Read the temp file from -d path\nwith open(args.data, 'r') as file:\n    content = json.load(file)\n\n# get the data and header key from the JSON    \ncihper_or_plaintext_in_base64 = content.get(\"data\")\nheader_in_base64 = content.get(\"header\")\n\n# Base64 decode to the original data and header\ncihper_or_plaintext = b64decode(cihper_or_plaintext_in_base64).decode('utf-8')\nheader_plaintext_list = b64decode(header_in_base64).decode('utf-8')\n\n\n## Your encryption logic\n\nprint(output)  # Only print output of cihper_or_plaintext not header as header is read only\n</code></pre> <pre><code>const fs = require('fs');\nconst path = require('path');\nvar CryptoJS = require(\"crypto-js\");\nconst { program } = require('commander');\nconst { Buffer } = require('buffer');\n\nprogram\n.option('-d, --data &lt;file_path&gt;', 'Path to JSON file containing base64 encoded + encrypted data');\n\nprogram.parse(process.argv);\nconst options = program.opts();\n\n// Read the -d value\nconst filePath = options.data;\n\n// reolve the full of -d provided path to avoid error in reading file.\nconst absoluteFilePath = path.resolve(filePath);\n\n// read the file.\nvar data = fs.readFileSync(absoluteFilePath).toString();\n\n//parse the json from the file\nconst jsonData = JSON.parse(data);\n\n// get the JSON data and header key value\nconst base64Data = jsonData.data; \nconst base64header = jsonData.header; \n\n// base64 decode the value to get original data and header.\nconst cihper_or_plaintext = Buffer.from(base64Data, 'base64').toString('utf8');\nconst plaintext_list_header = Buffer.from(base64header, 'base64').toString('utf8');\n\n///Your encryption logic here\n\n// print the output\nconsole.log(output) // Only print output of cihper_or_plaintext not header as header is read only\n</code></pre> <pre><code>import org.json.JSONObject;   //https://github.com/stleary/JSON-java\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.util.Base64;\n\npublic class AESCBC128Decrypt {\n\npublic static void main(String[] args) {\n\n    // Validate if -d is there or not\n    if (args.length != 2 || !args[0].equals(\"-d\")) {\n        System.out.println(\"Usage: java AESCBCDecrypt -d cipher-data-file-path\");\n        return;\n    }\n\n    // get -d value for temp file path\n    String ciphertextfilepath = args[1];\n    String base64Data = null;\n\n    // read the file content\n    try (FileReader reader = new FileReader(ciphertextfilepath)) {\n        // parse the file content as JSON\n        JSONObject jsonObject = new JSONObject(reader);\n\n        // parse JSON and get Data and header key from JSON Object\n        base64Data = (String) jsonObject.get(\"data\");\n        base64headerStr = (String) jsonObject.get(\"header\");\n\n    } catch (IOException  e) {\n        System.err.println(\"Error reading JSON file: \" + e.getMessage());\n    };\n    // base64 decode the value to get original data.\n    String cipher_plain_text = new String(Base64.getDecoder().decode(base64Data), StandardCharsets.UTF_8);\n    String header_in_plain_text = new String(Base64.getDecoder().decode(base64headerStr), StandardCharsets.UTF_8); // you can use it as string or convert to list\n\n    ///Your encryption logic here\n\n    // print the output\n    System.out.println(output); // Only print output of cipher_plain_text not header as header is read only\n\n}}\n</code></pre> <p>Warning</p> <p>Given the limitation of only being able to read the header, it is important to ensure that you only print the output of the encryption/decryption process on Data key value and not the header. </p>"},{"location":"Scripts/#custom-request-edit-headers","title":"Custom Request (Edit Headers)","text":"<p>Custom Request and Custom Request (Edit Header) have several similarities with a few key differences:</p> <ul> <li> <p>The header value in Custom Request is in a list/array format, whereas in Custom Request (Edit Header), the header is in raw format, just as you would see it in Burp Suite.</p> </li> <li> <p>Since Custom Request (Edit Header) allows for header editing, it's necessary to print the header as well, but in base64 format.</p> </li> <li> <p>The output of the encrypted/decrypted string/body will also be in the base64 format.</p> </li> <li> <p>It is important to print the base64 header first, followed by the base64 body/parameter.</p> </li> <li> <p>Since the header is in raw format, you can split it using new line characters (\\n) to edit or add new headers.</p> </li> <li> <p>When printing the updated header in base64, it should retain the same raw format. If you split the header with new line characters to make changes, you will need to join it again to restore it to the original raw format.</p> </li> </ul> <pre><code>{\"data\":\"cGxhaW50ZXh0\",\"header\":\"UE9TVCAvYXBpL2dldHVzZXI0IEhUVFAvMS4xCkhvc3Q6IDEyNy4wLjAuMTo4MDAwCkFjY2VwdC1FbmNvZGluZzogZ3ppcCwgZGVmbGF0ZQpBY2NlcHQ6ICovKgpTaWduYXR1cmU6IDA4NjFjMDBiODFlNWY2OTZkNGE5MjM3MGE4OTYxYzEyCkFjY2VwdC1MYW5ndWFnZTogZW4tVVM7cT0wLjksZW47cT0wLjgKVXNlci1BZ2VudDogTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEwMy4wLjUwNjAuMTM0IFNhZmFyaS81MzcuMzYKQ29ubmVjdGlvbjogY2xvc2UKQ2FjaGUtQ29udHJvbDogbWF4LWFnZT0wCkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbgpDb250ZW50LUxlbmd0aDogMzg=\"}\n</code></pre> <p>If you base64 decode the header you will see like this same as raw http request.</p> <pre><code>POST /api/getuser4 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nSignature: 0861c00b81e5f696d4a92370a8961c12\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 38\n</code></pre> PythonJavaScriptJava <pre><code>import argparse\nfrom base64 import b64decode,b64encode\nimport json\n\n# Create an argument parser\nparser = argparse.ArgumentParser(description='Process data argument')\nparser.add_argument('-d', '--data', help='File path with plaintext data + base64 in JSON format')\n\n# Parse the arguments\nargs = parser.parse_args()\n\n## Read the temp file from -d path\nwith open(args.data, 'r') as file:\n    content = json.load(file)\n\n# get the data and header key from the JSON    \ncihper_or_plaintext_in_base64 = content.get(\"data\")\nheader_in_base64 = content.get(\"header\")\n\n# Base64 decode to the original data and header\ncihper_or_plaintext = b64decode(cihper_or_plaintext_in_base64).decode('utf-8')\nheader_plaintext_list = b64decode(header_in_base64).decode('utf-8')\n\n## Your encryption logic\n\n## Update the header\n\n## print the base64 encoded header first then body\nprint(b64encode(updated_header))\nprint(b64encode(updatedbody))\n</code></pre> <pre><code>const fs = require('fs');\nconst path = require('path');\nvar CryptoJS = require(\"crypto-js\");\nconst { program } = require('commander');\nconst { Buffer } = require('buffer');\n\nprogram\n.option('-d, --data &lt;file_path&gt;', 'Path to JSON file containing base64 encoded + encrypted data');\n\nprogram.parse(process.argv);\nconst options = program.opts();\n\n// Read the -d value\nconst filePath = options.data;\n\n// reolve the full of -d provided path to avoid error in reading file.\nconst absoluteFilePath = path.resolve(filePath);\n\n// read the file.\nvar data = fs.readFileSync(absoluteFilePath).toString();\n\n//parse the json from the file\nconst jsonData = JSON.parse(data);\n\n// get the JSON data and header key value\nconst base64Data = jsonData.data; \nconst base64header = jsonData.header; \n\n// base64 decode the value to get original data and header.\nconst cihper_or_plaintext = Buffer.from(base64Data, 'base64').toString('utf8');\nconst plaintext_list_header = Buffer.from(base64header, 'base64').toString('utf8');\n\n\n'Your encryption and decryption logic should be here'\n'Updated the header'\n\n\n// print the updated base64 header and followed by updated base64 body\nconsole.log(Buffer.from(updatedheader).toString('base64'));\nconsole.log(Buffer.from(updatedbody).toString('base64'));\n</code></pre> <pre><code>import org.json.JSONObject;   //https://github.com/stleary/JSON-java\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.util.Base64;\n\npublic class AESCBC128Decrypt {\n\npublic static void main(String[] args) {\n\n    // Validate if -d is there or not\n    if (args.length != 2 || !args[0].equals(\"-d\")) {\n        System.out.println(\"Usage: java AESCBCDecrypt -d cipher-data-file-path\");\n        return;\n    }\n\n    // get -d value for temp file path\n    String ciphertextfilepath = args[1];\n    String base64Data = null;\n\n    // read the file content\n    try (FileReader reader = new FileReader(ciphertextfilepath)) {\n        // parse the file content as JSON\n        JSONObject jsonObject = new JSONObject(reader);\n\n        // parse JSON and get Data and header key from JSON Object\n        base64Data = (String) jsonObject.get(\"data\");\n        base64headerStr = (String) jsonObject.get(\"header\");\n\n    } catch (IOException  e) {\n        System.err.println(\"Error reading JSON file: \" + e.getMessage());\n    };\n    // base64 decode the value to get original data.\n    String cipher_plain_text = new String(Base64.getDecoder().decode(base64Data), StandardCharsets.UTF_8);\n    String header_in_plain_text = new String(Base64.getDecoder().decode(base64headerStr), StandardCharsets.UTF_8); // you can use it as string or convert to list\n\n    ///Your encryption logic here\n\n    // print the output\n    String updatedHeaderBase64 = Base64.getEncoder().encodeToString(updatedHeader.getBytes(StandardCharsets.UTF_8));\n    String updatedBase64Body = Base64.getEncoder().encodeToString(updatedBody.getBytes(StandardCharsets.UTF_8));\n\n    //print the header first then body\n    System.out.println(updatedHeaderBase64);\n    System.out.println(updatedBase64Body);\n\n}}\n</code></pre>"},{"location":"Scripts/#debug","title":"Debug","text":"<p>If you encounter difficulties decrypting or encrypting the request within the extension, it is important to ensure that your code is functioning correctly. To encrypt or decrypt the request body or string, you can follow these steps: </p> <ol> <li>Base64 encode the value you wish to encrypt or decrypt.</li> <li>Store the value in a file as JSON content like <code>{\"data\":\"your-base64-encoded-value-of-plaintext/encrypted-data\"}</code></li> <li>Execute the same command in your terminal or CMD, like youscript -d path-tofile</li> </ol> <p>By performing these steps, you can verify the functionality of the encryption or decryption process outside of the extension environment.</p> <p>Info</p> <p>The version 0.3 comes with logger support for debug. You can click on the Log tab and enable logging to see the background command execution for debugging.</p> <p>Info</p> <p>The temp file generated by the extension will be deleted as soon as command is execution is completed so from Log tab if you copy the same command and execute in your terminal if will give as error the path of the -d file will be deleted.</p>"},{"location":"Scripts/#demo-code","title":"Demo Code","text":"<p>If you are looking for demo encryption decryption code for common type of encryption or logic you can get it from the PyCript Template</p>"},{"location":"Select-Language/","title":"Select Language","text":""},{"location":"Select-Language/#selecting-language","title":"Selecting Language","text":"<p>The PyCript from version 0.4 supports multiple languages, and also it allows you to run scripts without needing the language in the system environment.</p> <p>In the earlier version, you could select the language from the drop-down from Python, Java and Nodejs and extensions except you to have these languages in your system environment so it should be accessible from anywhere in the system terminal or CMD.</p> <p>To work with different language you have to use different method to allow PyCript to execute the script or binary provided for encryption and decryption.</p> <p>The extension now allows you to select language binary like Python.exe or Go.exe or other binary based on your OS.</p> <p>You have 2 option </p> <ul> <li> <p>Click on the Select Language Binary Path button and select the language binary.</p> <p></p> </li> <li> <p>Or you can paste the full path directly into the text box.</p> <p></p> </li> </ul> <p>This is only if you don't have language in your system env and get an error as command not found such as python not found but it is installed. </p> <p>If it is in your env instead of full path you can type python or python3 or go or node etc in the text box as per your encryption decryption script language.</p>"},{"location":"Select-Language/#examples","title":"Examples","text":"<ul> <li>If you are using bash script for enc dec script you can just type <code>bash</code> or you can select shell path like <code>/bin/sh</code> or <code>/bin/bash</code></li> <li>If you are using powershell script for enc dec script you can type <code>powershell.exe -File</code></li> <li>If you are using Java you can just select the java binary full path or just type <code>java</code>. <ul> <li>you don't need to add <code>-jar</code> like <code>java -jar</code>, extension check if enc dec file is <code>.jar</code> it will auto add <code>-jar</code> to execute it.</li> </ul> </li> </ul>"},{"location":"Select-Language/#binary","title":"Binary","text":"<p>If you are providing an encryption-decryption file as binary like compiled code from C C++ or Go language or any other like C# etc. The compiled code doesn't need any language like python script.exe etc.</p> <p>For compiled binary, you can keep the language as empty, and make sure the text box is empty and does not have any value. The extension will run the executable directly.</p>"},{"location":"Select-Language/#notes","title":"Notes","text":"<ul> <li>You cannot have separate languages for encryption and decryption like encryption script is in Python and decryption in Java or any other both should be in the same language.</li> <li>The same is true for the request and response, you cannot have both encryption decryption scripts for requests in Python and for response both scripts are in another language.</li> <li>When using bash script you cannot use Windows WSL. Path for WSL and windows are different.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Warning</p> <p>Please make sure that all the prerequisites mentioned are installed first.</p>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<ul> <li>Download the PyCript repository from GitHub either by cloning the repository using  <code>git clone https://github.com/Anof-cyber/PyCript</code> or by downloading the repository as a zip file.</li> <li>Extract the contents of the zip file if you downloaded the repository as a zip file.</li> <li>Open Burp Suite, and navigate to the \"Extender\" tab.</li> <li>Click on the \"Add\" button to add a new extension.</li> <li>In the \"Extension Type\" field, select \"Python\"</li> <li>Click on the \"Select file\" button and browse to the location of the \"pycript.py\" file, which should be located in the PyCript repository that you downloaded.</li> <li>Click on the \"Open\" button to load the PyCript extension into Burp Suite.</li> <li>The PyCript extension should now be listed under the \"Extensions\" tab in Burp Suite, and you can use its features.</li> </ul>"},{"location":"installation/#burp-suite-bapp-store-installation","title":"Burp Suite BApp Store Installation","text":"<p>Info</p> <p>You can now install the extension from the Burp Suite BApp Store.</p>"},{"location":"workflow/","title":"Workflow","text":""},{"location":"workflow/#flow-of-the-extension","title":"Flow of the Extension","text":"<p>PyCript utilizes system commands to run user-specified encryption and decryption scripts. In the new version, the extension passes the HTTP request body or parameters as byte arrays and headers as plain raw text, storing them in a temporary file. The file also separates headers and body/parameters using the marker <code>\\n--BODY_END--\\n</code>. Instead of reading the script's output directly, PyCript executes the system command with the path to the temporary file provided to the user script. After execution, the extension reads the updated request or response data from the same temporary file, converting the byte array (body/parameters) back to strings and directly using the updated headers. These updated values are then replaced in the request or response within Burp Suite.</p>"},{"location":"workflow/#commands","title":"Commands","text":"<p>The PyCript extension generates a temp file (from version 1.00) and stores the request body/parameter and header in raw text + byte array format. The extension passes the temp file location to the encryption-decryption script using -d command line argument. The JSON data will be based on the PyCript configuration.</p> <ul> <li>node script.js -d tempfile-path</li> <li>python script.py -d tempfile-path</li> <li>java -jar script.jar -d tempfile-path</li> </ul> <p>The temp file will have encrypted/decrypted parameter or request body and request header in below format.</p> <pre><code>[118, 75, 85, 86, 118, 111, 50, 57, 112, 100, 76, 50, 105, 67, 101, 109, 82, 97, 116, 115, 85, 80, 122, 122, 102, 89, 106, 57, 43, 110, 81, 75, 101, 99, 90, 43, 83, 87, 51, 70, 75, 65, 117, 66, 90, 107, 82, 101, 77, 75, 105, 80, 82, 74, 107, 112, 105, 53, 86, 66, 122, 89, 119]\n--BODY_END--\nPOST /complete-body/api/2 HTTP/1.1\nHost: 127.0.0.1:8000\nContent-Length: 64\nsec-ch-ua-platform: \"Windows\"\n</code></pre> <p>Note</p> <p>header is only available for request encryption decryption not for response.</p> <p>Note</p> <p>Header can only be edited if Request Type is Complete Body.</p> <p>Note</p> <p>In case of response encryption/decryption temp file will be no data after <code>--BODY_END--</code>as no headers are there for response.</p> <ul> <li>Complete Body - The extension will take the request/response body convert it in byte array format, take raw plaintext header, save the file in above format.</li> <li> <p>Parameter Value - PyCript is designed to iterate through the request/response parameter values and convert it in byte array format take raw plaintext header, save the file in above format. It will then update each value one by one.</p> </li> <li> <p>Parameter key and value - The PyCript extension adopts a similar approach to that of parameter value. It iterates through each parameter name and value and convert it in byte array format take raw plaintext header, save the file in above format, passing them one by one to the script for updating.</p> </li> </ul>"},{"location":"workflow/#usage","title":"Usage","text":"<ul> <li>Start by loading the PyCript extension into Burp Suite.</li> <li>Choose the language you want to use for encryption and decryption. (See Select Language for more details)</li> <li>Load the encryption and decryption file.</li> <li>Decide whether you want to apply encryption and decryption to the request, response, or both, and select the appropriate type.</li> <li>For request encryption and decryption, specify the method you want to use (GET, BODY, or Both).</li> <li>Select the Request or Response Type like Complete Body, Paramter Value etc.</li> <li>Make sure the URL you want to work with is within the scope of Burp Suite.</li> <li>Once you've located the encrypted request or response, a new PyCript tab will be generated next to it, with a plaintext version that you can edit as needed.</li> </ul>"},{"location":"workflow/#parameters","title":"Parameters","text":"<p>It is important to verify the supported request parameters or content types by PyCript. The following methods encompass the content types and parameters supported by PyCript:</p> Body ParametersJSON <p>The PyCript extension leverages the APIs offered by Burp Suite to examine get and body parameters. However, there may be situations where its performance is suboptimal when faced with encrypted or encoded parameters containing multiple <code>=</code> characters. If you encounter challenges in parsing such requests, it is recommended to use the complete body options and incorporate customized parsing into your script.</p> <pre><code>POST /crypto/myprofile?username=KtKB81Oamvuzo9entPFKZQ%3d%3d&amp;password=KtKB81Oamvuzo9entPFKZQ%3d%3d HTTP/1.1\nHost: localhost:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 24\n\nusername=KtKB81Oamvuzo9entPFKZQ%3d%3d&amp;password=KtKB81Oamvuzo9entPFKZQ%3d%3d\n</code></pre> <p>PyCript has included JSON support since its initial release. The extension utilizes custom parsing methods to handle JSON objects, as Burp Suite itself does not natively support direct manipulation of JSON objects. Starting from version 0.2, PyCript extends its support to handle nested and complex JSON objects.</p> <pre><code>POST /crypto/login/ HTTP/1.1\nHost: localhost:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 77\n\n{\"username\":\"HgE40uCnUDbOfuat6om5QA==\",\"password\":\"FZbf3I/h9ORUV+H6Wzv4gA==\"}\n</code></pre> <p>Info</p> <p>The version 1.0 support multipart form data as well. Multi part form can have file upload data as well, It is recommended to add the file upload parameter name in the parameter exclusion list.</p>"}]}