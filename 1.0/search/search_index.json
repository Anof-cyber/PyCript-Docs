{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The Pycript extension for Burp Suite is a valuable tool for penetration testing and security professionals. It enables easy encryption and decryption of requests during testing, which can help evade detection and bypass security measures. The extension also offers the ability to customize the encryption and decryption process by writing custom logic using JavaScript and Node.js, making it a highly adaptable tool for various needs. Additionally, it supports both manual and automated testing, as well as custom encryption/decryption plugins, making it a versatile solution for different penetration testing scenarios.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ability to decrypt requests and modify data in real-time</li> <li>Provides JavaScript and NodeJS support for custom encryption and decryption logic.</li> <li>The ability to retrieve the encryption key and IV directly from the request header and body using Burpsuite and JavaScript.</li> <li>Supports decryption of multiple requests </li> <li>Use auto-encryption to perform an automated burp scan or sqlmap</li> </ul>"},{"location":"#sponsor","title":"Sponsor","text":""},{"location":"#team","title":"Team","text":""},{"location":"#sourav-kalal","title":"Sourav Kalal","text":""},{"location":"#documentation","title":"Documentation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#select-language","title":"Select Language","text":""},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#writing-custom-scripts","title":"Writing Custom Scripts","text":""},{"location":"#video","title":"Video","text":""},{"location":"Examples/","title":"Usage Examples","text":""},{"location":"Examples/#config","title":"Config","text":"<p>The configuration tab contains all the necessary settings to enable encryption and decryption functionality. Within the configuration, you can select whether to apply encryption and decryption to requests, responses, or both. Additionally, you can specify the preferred programming language and load any necessary encryption/decryption files, among other options.</p> <p>Warning</p> <p>This extension is designed to operate exclusively on URLs that have been included within the target scope of Burp Suite.</p> <p>Warning</p> <p>PyCript version 1.0 change the use of encryption decryption language as well how it pass data to the encryption decryption script over command line argument. Older script will not work with new PyCript. Check the \"Select Language\" and \"Writing Custom Scripts\" page.</p>"},{"location":"Examples/#request-type","title":"Request Type","text":"<p>The Request Type feature enables you to choose the specific request or message type that requires encryption or decryption.</p> Complete BodyParameter Value <p>The \"Complete Body\" provides the capability to modify the request header an body, means complete request. This functionality is not limited to editing alone; you can also add or delete headers as needed. It proves to be particularly useful in applications where data modification is restricted through various proxy or validation mechanisms, such as adding a signature to request parameters or body and enforcing signature verification to prevent any value modification, Or you want to parse the request with your own script.</p> <p>By selecting the \"Complete Body\" option, Pycript will take the entire request body in Byte Array Format and Headers in plain text format and pass it to the encryption and decryption script provided by the user. This allows for seamless integration of your own encryption and decryption logic with Burp Suite.</p> <p>When dealing with multiple parameters, where only the parameter values are encrypted, the parameter value can be retrieved from query parameters, JSON values, or body parameters. The PyCript module handles this process by passing one parameter value at a time to the user-provided script. The complete body or parameters are not passed to the script. Instead PyCript loop through each parameter, convert its value to Byte Array and passes with to User Script along with Plain text Header.</p> <p>Parameter value allow your script to read header as well. Your script cannot provide edited headers. You can only update parameter values not request headers. </p>"},{"location":"Examples/#response-type","title":"Response Type","text":"<p>The Response Type feature enables you to choose the specific response or message type that requires encryption or decryption.</p> <p>Warning</p> <p>The encryption and decryption of responses were introduced in PyCript v0.2. Please note that this functionality is currently limited to JSON response content types.</p> <p>Info</p> <p>If your complete response body is encrypted and there are possibilities that body will be in double/single quotes. You need to handle the same in your script.</p> <p>Info</p> <p>The Response Type in your Burp Suite extension mirrors the functionality of the request type. In fact, you can utilize the same script for both request and response actions.</p> <p>Info</p> <p>The Response Type does not allow you to edit headers in the response. </p>"},{"location":"Examples/#additional-setting","title":"Additional Setting","text":"<p>The Additional settings in your Burp Suite extension allow you to configure the following options:</p> <code>Language</code> <p>You can select the language that will be used for encryption and decryption. It's important to note that the same language will be applied to both request and response, as well as for both encryption and decryption operations.</p> <code>Clear Language Selection</code> <p>You can use the button to remove the selected language. You don't need to define the language when encryption decryption is in binary format like compiled code from C++ or C etc.</p> <code>Encryption Method</code> <p>This option is available only for request-related settings. You can choose the encryption method to be applied to the GET parameters, request body, or both.</p> <code>Encryption/Decryption For</code> <p>Here, you can select whether you want to perform encryption and decryption operations for the request, response, or both. Additionally, you will need to specify the request and response types to define the scope of these operations.</p>"},{"location":"Examples/#request-encryption-files","title":"Request Encryption Files","text":"<p>To encrypt and decrypt request data, you have the option to choose the encryption and decryption files. It's important to select the appropriate file based on the programming language specified in the additional settings.</p>"},{"location":"Examples/#response-encryption-files","title":"Response Encryption Files","text":"<p>For encrypting and decrypting response data, you can also select the encryption and decryption files. Make sure to choose the file that aligns with the programming language selected in the additional settings.</p>"},{"location":"Examples/#auto-encrypt","title":"Auto Encrypt","text":"<p>The auto-encryption feature enables you to encrypt requests within your Burp Suite extension. It allows you to specify the tool type for which the request should be encrypted. This functionality is particularly useful when performing automated scans, such as Burp Suite Active Scan or SQLMAP.</p> <p>When dealing with an encrypted request that needs to be scanned using the Burp Suite scanner, a challenge arises because adding any payload in plain text format to an encrypted parameter would result in the server rejecting the request. This rejection occurs because the server fails to decrypt the request on its side.</p> <p>To address this issue, you can provide the decrypted request to the scanner and activate the \"Auto Encrypt\" option. Additionally, you can select the appropriate tool type for the scanner.</p> <p>By doing so, the scanner will receive the decrypted request and add any necessary payload. Subsequently, the extension will encrypt the request (based on the selected Request Type) before the scanner sends it to the server.</p> <p>Similarly, for SQLMAP, you can supply the decrypted request and configure SQLMAP to send all requests to the Burp proxy. Make sure to enable the \"Auto Encrypt\" option in this case as well.</p>"},{"location":"Examples/#menu","title":"Menu","text":"<p>PyCript offers several additional options accessible through the right-click menu. To access these options, simply right-click on any request within Burp Suite, whether it's in Repeater, Target, Proxy, or elsewhere. In the menu that appears, you will find an \"Extensions\" option, and within that submenu, you will see \"PyCript.\"</p> <p>Upon selecting the PyCript submenu, you will be presented with three distinct options:</p> <ul> <li> <p>Decrypt Request: This option allows you to decrypt the request, enabling you to analyze its contents in its original, unencrypted form. The decrypted request will be stored in the PyCript extension for easy access. You can find it in the \"PyCript\" tab, under the \"Decrypted Request\" sub-tab.</p> </li> <li> <p>Decrypt String: With this option, you can select any data within the request and response. PyCript will then show you the decrypted version of the selected string, providing a way to analyze the decrypted data.</p> </li> <li> <p>Encrypt String: This option allows you to encrypt selected data within the request and response. PyCript will show you the encrypted version of the selected string.</p> </li> </ul> <p></p> <p>Info</p> <p>When selecting a string from the request in your Burp Suite extension, the encryption/decryption script used for the request will be applied. If you have not added an encryption/decryption script specifically for the request, the script associated with the response will be utilized instead. Similarly, if you choose a string from the response, the corresponding encryption/decryption script will be used accordingly.</p>"},{"location":"Prerequisites/","title":"Prerequisites","text":""},{"location":"Prerequisites/#prerequisites","title":"Prerequisites","text":"<p>PyCript provides the flexibility to implement custom encryption and decryption algorithms using any programming language. To utilize PyCript, one must have a compiled binary of the custom encryption and decryption code with Windows PE or Mach-O etc or the language to run the script or executable like Go, Python, Nodejs etc.</p> <ul> <li>Burp Suite configured with Jython to install the Python extension </li> </ul> <p>Note</p> <p>PyCript v1.0 change the working of the extension, the older script of encryption and decryption will not work with version 1.0</p> <p>Note</p> <p>If you choose to use the Java programming language with PyCript, you will require a JAR file to be provided. Please ensure that you include the JAR file, and not the compiled class file or Java source code, when using PyCript.</p> <p>Note</p> <p>When opting to utilize JavaScript with PyCript, it's essential to ensure that all necessary libraries are present in the folder where encryption and decryption files are stored. This is particularly important as many Node.js libraries require the presence of related dependencies in the same directory as node_modules.</p>"},{"location":"Scripts/","title":"Writing Custom Scripts","text":""},{"location":"Scripts/#working-of-the-extension","title":"Working of the Extension","text":"<p>The extension utilizes user provided encryption decryption files for executing encryption and decryption operations by running system commands.</p>"},{"location":"Scripts/#demo-code","title":"Demo Code","text":"<p>If you are looking for demo encryption decryption code for common type of encryption or logic you can get it from the PyCript Template</p> <p>Warning</p> <p>PyCript version 1.0 always pass headers along with body or parameter. Where Headers are Editable with Complete Body Type. Older PyCript Custom Script will not work.</p> <p>Warning</p> <p>PyCript version 1.0 use Byte array as parameter/body  value like [80, 53, 50] instead of Base64.</p> <p>PyCript expect user to provide encryption decryption code file, the code languages could be anything Like Python, Java, JavaScript, Go, Bash script, Powershell script, C/C++ or Any. Check Select Language page for more details.</p> <p>Info</p> <p>From PyCript version 0.4 you can use any language for encryption decryption as long as it uses the format of PyCript to read data and pass data to and from PyCript.</p> <p>Info</p> <p>Check the Dummy Code repository PyCript Template Has example codes in  JavaScript</p> <p>PyCript run system command to execute the script or binary provided for encryption and decryption. User is suppose to provide the language path. Check Select Language page for more details.</p> <p>Next user is suppose to provide the encryption decryption file path. Later based on the setting on PyCript config tab, the extension will provided the encrypted decrypted body/parameter/header to the script.</p>"},{"location":"Scripts/#pycript-flow-for-request-decryption","title":"PyCript Flow for Request Decryption","text":"<ul> <li>Take Request body [If Request Type is Complete Body], Convert it into the Byte Array format like [80, 44, 56].<ul> <li>If Request Type is Parameter Value or Parameter Key Value, PyCript will loop each parameter from Script. Convert to Byte Array Format.</li> </ul> </li> <li>PyCript create a Temp file, Save the Byte Array body/parameter/Parameter Key along with Plain with Raw Header and will use <code>--BODY_END--</code> to separate them.</li> </ul> <p>Example Temp Files with Original Request in Burp Suite:</p> <p>Example Request in Burp Suite</p> <pre><code>```http\nPOST / HTTP/2\nHost: google.com\nAccept-Encoding: gzip, deflate, br\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 16\n\n\nEnCRYPTED-BODY\n```\n</code></pre> <p>Example Temp File Create By PyCript</p> <pre><code>[69, 110, 67, 82, 89, 80, 84, 69, 68, 45, 66, 79, 68, 89]\n--BODY_END--\nPOST / HTTP/2\nHost: google.com\nAccept-Encoding: gzip, deflate, br\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 16\n</code></pre> <p>In case of Parameter Key or Parameter Key value is used, for each parameter and key a temp file will be created by PyCript and each will have Byte array instead of Body Byte Array. </p> <p>You can convert it back to string before decryption and encryption like below Python and JavaScript example code</p> PythonNodeJS <pre><code>ascii_values = [69, 110, 67, 82, 89, 80, 84, 69, 68, 45, 66, 79, 68, 89]\nresult = ''.join(chr(value) for value in ascii_values)\nprint(result)\n</code></pre> <pre><code>const asciiValues = [69, 110, 67, 82, 89, 80, 84, 69, 68, 45, 66, 79, 68, 89];\nconst result = String.fromCharCode(...asciiValues);\nconsole.log(result);\n</code></pre> <ul> <li>Once the temp file is created PyCript  will execute the user provided encryption/decryption script and will provide the path of the temp file to user script like:</li> </ul> <pre><code>/user/path/to/language/like/node user/file/path/encryption.js -d temp-file-path\n</code></pre>"},{"location":"Scripts/#command-line-argument-for-bodyparameters","title":"Command Line Argument for Body/Parameters","text":"<p>The extension utilizes the -d command line argument to pass the full path of the temp file storing the Byte body or parameters along with Plain text headers to the encryption/decryption code. If you are writing a script, ensure that your script supports command line arguments with the -d flag.</p> <p>The value provided with the -d argument will be the path of the temp file. The temp file will split the parameter/body and Header with <code>--BODY_END--</code>. Your script need to split the data with divider <code>--BODY_END--</code> to get parameter/body separately and headers separately. Once one your script can convert the Byte to String for body/parameter value.</p>"},{"location":"Scripts/#byte-array-for-string-consistency","title":"Byte array for String Consistency","text":"<p>The extension uses Byte array from version 1.0 to support binary data, Non ASCII data in request body.</p>"},{"location":"Scripts/#performing-actions-and-adding-logic","title":"Performing Actions and Adding Logic","text":"<p>Your code can perform any action or add any logic to the provided value. Once your script is done with the changes on request body/parameter and header. your script should again change the request body/parameter in same byte array format.</p> <p>Save the updated request in the same temp file provided on -d argument by the PyCript. Updated request should be in same format like:</p> <pre><code>[69, 110, 67, 82, 89, 80, 84, 69, 68, 45, 66, 79, 68, 89]\n--BODY_END--\nPOST / HTTP/2\nHost: google.com\nAccept-Encoding: gzip, deflate, br\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 16\n</code></pre> <ul> <li>PyCript validate if command to execute encryption/decryption had any error, If not will try to read the same temp file to get updated request. Convert the Byte array for Parameter/Body to String and Updated the Request headers and Body/parameter in request.</li> </ul>"},{"location":"Scripts/#encryption-and-decryption-code","title":"Encryption and Decryption Code","text":"<p>The same logic described above is applicable to encryption and decryption code as well. Ensure that your code follows the specified format and guidelines for encryption and decryption operations.</p>"},{"location":"Scripts/#notes","title":"Notes","text":"<ul> <li>All Request Type will have headers in the temp file. Your script can read header header in all Request Type</li> <li>Only Request Type Complete Body allows your script to provide ability to Provide updated header so PyCript can update header as well. </li> <li>Even if you select Request Type as Parameter Value or Parameter Key Value, where your script can only read header cannot provide updated headers. Your script must add <code>--BODY_END--</code> in the temp file.</li> <li>Response encryption decryption does get header. Your script will only have Response Body or Parameters not header but your script must add <code>--BODY_END--</code> in the temp file.</li> <li>PyCript will always add <code>--BODY_END--</code> at the end of Parameter/Body even if header is not there. It always recommended to split the request to remove the <code>--BODY_END--</code> even if header is not here like for Response.</li> </ul> PythonJavaScript <pre><code>import json\nfrom pathlib import Path\nimport argparse\n\n# Function to handle AES decryption\ndef decrypt_aes(ciphertext):\n    # your logic to decrypt the ciphertext\n    decrypted = ciphertext\n    return decrypted\n\n# Function to read and parse the header\ndef read_parse_header(headers_raw):\n    # Logic to edit header if needed\n    return headers_raw\n\n# Parse command-line arguments\nparser = argparse.ArgumentParser(description='Process encrypted/decrypted data.')\nparser.add_argument('-d', '--data', required=True, help='Path to temp file containing request/response data')\nargs = parser.parse_args()\n\n# Resolve file path and read the file\nfile_path = Path(args.data).resolve()\ndata = file_path.read_text(encoding='utf-8')\n\n# Split the data into body and header\nbody_end_marker = '\\n--BODY_END--\\n'   # Marker to separate body and header, remove the new line character as well\nbyte_array_str, headers_raw = data.split(body_end_marker)\n\n# Convert byte array string to bytes\nbyte_array = json.loads(byte_array_str.strip())\nciphertext = bytes(byte_array).decode('utf-8')   # convert byte array to string to get original ciphertext/plaintext same as burp Suite. or you can do ''.join(chr(value) for value in byte_array_str)\n\n\n# Decrypt the ciphertext\noriginal_text = decrypt_aes(ciphertext)\n# Parse and update the header\nupdated_header = read_parse_header(headers_raw)\n\nupdated_output_byte = [ord(char) for char in original_text] # Convert the updated string to byte array, only the data, parameter or body, not the header\noutput = f\"{json.dumps(updated_output_byte)}{body_end_marker}{updated_header}\"  # create the same format as byte array string \\n--BODY_END--\\n Plaintext header\nfile_path.write_text(output, encoding='utf-8') # Write back to the same file , you need to overwrite to replace old request with new in the temp file.\n</code></pre> <pre><code>const fs = require('fs');\nconst path = require('path');\nvar CryptoJS = require(\"crypto-js\");\nconst { program } = require('commander');\nconst { Buffer } = require('buffer');\n\nprogram\n.option('-d, --data &lt;file_path&gt;', 'Path to JSON file containing base64 encoded + encrypted data');\n\nprogram.parse(process.argv);\nconst options = program.opts();\n\nconst filePath = options.data;\nconst absoluteFilePath = path.resolve(filePath); // Get the absolute path of the file FROM -d option\nvar data = fs.readFileSync(absoluteFilePath, 'utf8')  // Read the file data\nconst bodyEndMarker = '\\n--BODY_END--\\n';  // Marker to separate body and headers\nconst [byteArrayStr, headersRaw] = data.split(bodyEndMarker); // Split the data into byte array and headers\n\nconst byteArray = JSON.parse(byteArrayStr.trim())  \nconst buffer = Buffer.from(byteArray); // Convert byte array to Buffer\nconst ciphertext = buffer.toString('utf8') // convert it string \n\n\n// call the functions to handle decrpytion, headers \nconst originalText = Decryption(ciphertext);\nconst updatedHeader = Read_parse_Header(headersRaw);\n\n\nconst updated_output_byte = Array.from(originalText).map(char =&gt; char.charCodeAt(0)); // convert the updated string to byte array again\nvar output = updated_output_byte +\"\\n--BODY_END--\\n\"+updatedHeader  // create the final output string in the same format as input file\nfs.writeFileSync(absoluteFilePath,output)  // write to same temp file in same formamt body\\n--BODY_END--\\nheader\n\nfunction Decryption(ciphertext) {\n    // your logic to decrypt/encrypt the ciphertext and return updated text\nreturn ciphertext;\n}\n\nfunction Read_parse_Header(headersRaw) {\n// logic to read/edit header\nreturn headersRaw;\n}\n</code></pre>"},{"location":"Scripts/#parsing-headers","title":"Parsing Headers","text":"<p>The headers are in the raw format, For Request Type Complete body, you can read, edit the headers and save the updated header in the temp file. In case of other request type selected, you can read the headers to get any value you want you can edit as well in your script.</p> <p>PyCript will ignore the headers from the temp file even if your script has updated if the request type is not completed body. But in any case if you want to read header to get values or read and update headers. you have to parse the headers</p> <p>To parse the headers you can split the headers like below </p> <pre><code>POST /api/getuser4 HTTP/1.1\nHost: 127.0.0.1:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nSignature: 0861c00b81e5f696d4a92370a8961c12\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/json\nContent-Length: 38\n</code></pre> PythonJavaScript <pre><code>#to just read the headers \nheadersplit = header.splitlines()\nHost = next((line for line in headersplit if line.startswith('Host:')), None)\nUser_Agent = next((line for line in headersplit if line.startswith('User-Agent:')), None)\n\n#to read or edit the header value so you can save updated output file\nheadersplit = header.splitlines()\nfor i, line in enumerate(headersplit):\n    if line.startswith('Host:'):\n        headersplit[i] = 'Host: updated.host.com'\n        break\n# rejoin the header, this is important\nupdatedheader = '\\r\\n'.join(headersplit)  # we can now save updatedheader in the temp file.\n</code></pre> <pre><code>// to just read the headers \nconst headersplit = header.split(/\\r?\\n/);\nconst Host = headersplit.find(line =&gt; line.startsWith('Host:'));   \nconst User_Agent = headersplit.find(line =&gt; line.startsWith('User-Agent:'));\n\n// to read or edit the header value so you can save updated output file\n\nvar headersplit = header.split(/\\r?\\n/)\nfor (var i = 0; i &lt; headersplit.length; i++) {\nif (headersplit[i].startsWith('Host:')) {\n    headersplit[i] = 'Host: updated.host.com' ;\n    break;\n    }\n}\n// rejoin the header, this is important\nvar updatedheader = headersplit.join(\"\\r\\n\")  // we can now save updatedheader in the temp file.\n</code></pre>"},{"location":"Scripts/#debug","title":"Debug","text":"<p>If you encounter difficulties decrypting or encrypting the request within the extension, it is important to ensure that your code is functioning correctly. To encrypt or decrypt the request body or string, you can follow these steps: </p> <ol> <li>The log tab within the PyCript will always print the value of temp file created by the PyCript.</li> <li>If your script is not working or having some errors, you can manually save the temp file data from the log tab and run your script locally on that data.</li> <li>Temp file created by the PyCript is deleted as soon as your script is execution is completed for that PyCript write the temp file data to logs in case you need it for debugging.</li> <li>If your script does not have any errors its working but you are not getting expected output in the Burp Suite request. It could be error from PyCript to read the updated temp file or could error from your script.</li> <li>To debug the cause you can add as many print in your script. you can even print the final output from your script along with saving it into the the file and can see the print output in the PyCript log to verify if your script is giving correct output or not.</li> </ol> <p>Info</p> <p>The version 0.3 comes with logger support for debug. You can click on the Log tab and enable logging to see the background command execution for debugging.</p> <p>Info</p> <p>The temp file generated by the extension will be deleted as soon as command is execution is completed so from Log tab if you copy the same command and execute in your terminal if will give as error the path of the -d file will be deleted.</p>"},{"location":"Select-Language/","title":"Select Language","text":""},{"location":"Select-Language/#selecting-language","title":"Selecting Language","text":"<p>The PyCript from version 0.4 supports multiple languages, and also it allows you to run scripts without needing the language in the system environment.</p> <p>In the earlier version, you could select the language from the drop-down from Python, Java and Nodejs and extensions except you to have these languages in your system environment so it should be accessible from anywhere in the system terminal or CMD.</p> <p>To work with different language you have to use different method to allow PyCript to execute the script or binary provided for encryption and decryption.</p> <p>The extension now allows you to select language binary like Python.exe or Go.exe or other binary based on your OS.</p> <p>You have 2 option </p> <ul> <li> <p>Click on the Select Language Binary Path button and select the language binary.</p> <p></p> </li> <li> <p>Or you can paste the full path directly into the text box.</p> <p></p> </li> </ul> <p>This is only if you don't have language in your system env and get an error as command not found such as python not found but it is installed. </p> <p>If it is in your env instead of full path you can type python or python3 or go or node etc in the text box as per your encryption decryption script language.</p>"},{"location":"Select-Language/#examples","title":"Examples","text":"<ul> <li>If you are using bash script for enc dec script you can just type <code>bash</code> or you can select shell path like <code>/bin/sh</code> or <code>/bin/bash</code></li> <li>If you are using powershell script for enc dec script you can type <code>powershell.exe -File</code></li> <li>If you are using Java you can just select the java binary full path or just type <code>java</code>. <ul> <li>you don't need to add <code>-jar</code> like <code>java -jar</code>, extension check if enc dec file is <code>.jar</code> it will auto add <code>-jar</code> to execute it.</li> </ul> </li> </ul>"},{"location":"Select-Language/#binary","title":"Binary","text":"<p>If you are providing an encryption-decryption file as binary like compiled code from C C++ or Go language or any other like C# etc. The compiled code doesn't need any language like python script.exe etc.</p> <p>For compiled binary, you can click on the Clear Language Selection to remove it, directly removing just from the text will not work as language path are persistent. The extension will run the executable directly.</p>"},{"location":"Select-Language/#notes","title":"Notes","text":"<ul> <li>You cannot have separate languages for encryption and decryption like encryption script is in Python and decryption in Java or any other both should be in the same language.<ul> <li>You can have different language if its compiled code like for Windows EXE one is C++ one in GO or C# etc.</li> </ul> </li> <li>The same is true for the request and response, you cannot have both encryption decryption scripts for requests in Python and for response both scripts are in another language.</li> <li>When using bash script you cannot use Windows WSL. Path for WSL and windows are different.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Warning</p> <p>Please make sure that all the prerequisites mentioned are installed first.</p>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<ul> <li>Download the PyCript repository from GitHub either by cloning the repository using  <code>git clone https://github.com/Anof-cyber/PyCript</code> or by downloading the repository as a zip file.</li> <li>Extract the contents of the zip file if you downloaded the repository as a zip file.</li> <li>Open Burp Suite, and navigate to the \"Extender\" tab.</li> <li>Click on the \"Add\" button to add a new extension.</li> <li>In the \"Extension Type\" field, select \"Python\"</li> <li>Click on the \"Select file\" button and browse to the location of the \"pycript.py\" file, which should be located in the PyCript repository that you downloaded.</li> <li>Click on the \"Open\" button to load the PyCript extension into Burp Suite.</li> <li>The PyCript extension should now be listed under the \"Extensions\" tab in Burp Suite, and you can use its features.</li> </ul>"},{"location":"installation/#burp-suite-bapp-store-installation","title":"Burp Suite BApp Store Installation","text":"<p>Info</p> <p>You can now install the extension from the Burp Suite BApp Store.</p>"},{"location":"workflow/","title":"Workflow","text":""},{"location":"workflow/#flow-of-the-extension","title":"Flow of the Extension","text":"<p>PyCript utilizes system commands to run user-specified encryption and decryption scripts. In the new version, the extension passes the HTTP request body or parameters as byte arrays and headers as plain raw text, storing them in a temporary file. The file also separates headers and body/parameters using the marker <code>\\n--BODY_END--\\n</code>. Instead of reading the script's output directly, PyCript executes the system command with the path to the temporary file provided to the user script. After execution, the extension reads the updated request or response data from the same temporary file, converting the byte array (body/parameters) back to strings and directly using the updated headers. These updated values are then replaced in the request or response within Burp Suite.</p>"},{"location":"workflow/#commands","title":"Commands","text":"<p>The PyCript extension generates a temp file (from version 1.00) and stores the request body/parameter and header in raw text + byte array format. The extension passes the temp file location to the encryption-decryption script using -d command line argument. The JSON data will be based on the PyCript configuration.</p> <ul> <li>node script.js -d tempfile-path</li> <li>python script.py -d tempfile-path</li> <li>java -jar script.jar -d tempfile-path</li> </ul> <p>The temp file will have encrypted/decrypted parameter or request body and request header in below format.</p> <pre><code>[118, 75, 85, 86, 118, 111, 50, 57, 112, 100, 76, 50, 105, 67, 101, 109, 82, 97, 116, 115, 85, 80, 122, 122, 102, 89, 106, 57, 43, 110, 81, 75, 101, 99, 90, 43, 83, 87, 51, 70, 75, 65, 117, 66, 90, 107, 82, 101, 77, 75, 105, 80, 82, 74, 107, 112, 105, 53, 86, 66, 122, 89, 119]\n--BODY_END--\nPOST /complete-body/api/2 HTTP/1.1\nHost: 127.0.0.1:8000\nContent-Length: 64\nsec-ch-ua-platform: \"Windows\"\n</code></pre> <p>Note</p> <p>header is only available for request encryption decryption not for response.</p> <p>Note</p> <p>Header can only be edited if Request Type is Complete Body.</p> <p>Note</p> <p>In case of response encryption/decryption temp file will have no data after <code>--BODY_END--</code> as no headers are there for response.</p> <ul> <li>Complete Body - The extension will take the request/response body convert it in byte array format, take raw plaintext header, save the file in above format.</li> <li> <p>Parameter Value - PyCript is designed to iterate through the request/response parameter values and convert it in byte array format take raw plaintext header, save the file in above format. It will then update each value one by one.</p> </li> <li> <p>Parameter key and value - The PyCript extension adopts a similar approach to that of parameter value. It iterates through each parameter name and value and convert it in byte array format take raw plaintext header, save the file in above format, passing them one by one to the script for updating.</p> </li> </ul> <p></p>"},{"location":"workflow/#usage","title":"Usage","text":"<ul> <li>Start by loading the PyCript extension into Burp Suite.</li> <li>Choose the language you want to use for encryption and decryption. (See Select Language for more details)</li> <li>Load the encryption and decryption file.</li> <li>Decide whether you want to apply encryption and decryption to the request, response, or both, and select the appropriate type.</li> <li>For request encryption and decryption, specify the method you want to use (GET, BODY, or Both).</li> <li>Select the Request or Response Type like Complete Body, Paramter Value etc.</li> <li>Make sure the URL you want to work with is within the scope of Burp Suite.</li> <li>Once you've located the encrypted request or response, a new PyCript tab will be generated next to it, with a plaintext version that you can edit as needed.</li> </ul>"},{"location":"workflow/#parameters","title":"Parameters","text":"<p>It is important to verify the supported request parameters or content types by PyCript. The following methods encompass the content types and parameters supported by PyCript:</p> Body ParametersJSON <p>The PyCript extension leverages the APIs offered by Burp Suite to examine get and body parameters. However, there may be situations where its performance is suboptimal when faced with encrypted or encoded parameters containing multiple <code>=</code> characters. If you encounter challenges in parsing such requests, it is recommended to use the complete body options and incorporate customized parsing into your script.</p> <pre><code>POST /crypto/myprofile?username=KtKB81Oamvuzo9entPFKZQ%3d%3d&amp;password=KtKB81Oamvuzo9entPFKZQ%3d%3d HTTP/1.1\nHost: localhost:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 24\n\nusername=KtKB81Oamvuzo9entPFKZQ%3d%3d&amp;password=KtKB81Oamvuzo9entPFKZQ%3d%3d\n</code></pre> <p>PyCript has included JSON support since its initial release. The extension utilizes custom parsing methods to handle JSON objects, as Burp Suite itself does not natively support direct manipulation of JSON objects. Starting from version 0.2, PyCript extends its support to handle nested and complex JSON objects.</p> <pre><code>POST /crypto/login/ HTTP/1.1\nHost: localhost:8000\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 77\n\n{\"username\":\"HgE40uCnUDbOfuat6om5QA==\",\"password\":\"FZbf3I/h9ORUV+H6Wzv4gA==\"}\n</code></pre> <p>Info</p> <p>The version 1.0 support multipart form data as well. Multi part form can have file upload data as well, It is recommended to add the file upload parameter name in the parameter exclusion list.</p>"}]}